// automatically generated by the FlatBuffers compiler, do not modify

#ifndef FLATBUFFERS_GENERATED_BASIC_AM_FB_H_
#define FLATBUFFERS_GENERATED_BASIC_AM_FB_H_

#include "flatbuffers/flatbuffers.h"

namespace AM
{
namespace fb
{
struct Entity;
struct EntityBuilder;

struct EntityUpdate;
struct EntityUpdateBuilder;

enum class InputState : int8_t {
    Invalid = 0,
    Pressed = 1,
    Released = 2,
    MIN = Invalid,
    MAX = Released
};

inline const InputState (&EnumValuesInputState())[3]
{
    static const InputState values[]
        = {InputState::Invalid, InputState::Pressed, InputState::Released};
    return values;
}

inline const char* const* EnumNamesInputState()
{
    static const char* const names[4]
        = {"Invalid", "Pressed", "Released", nullptr};
    return names;
}

inline const char* EnumNameInputState(InputState e)
{
    if (flatbuffers::IsOutRange(e, InputState::Invalid, InputState::Released))
        return "";
    const size_t index = static_cast<size_t>(e);
    return EnumNamesInputState()[index];
}

struct Entity FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
    typedef EntityBuilder Builder;
    struct Traits;
    enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
        VT_ID = 4,
        VT_X = 6,
        VT_Y = 8,
        VT_Z = 10,
        VT_VELX = 12,
        VT_VELY = 14,
        VT_VELZ = 16,
        VT_INPUTSTATES = 18
    };
    uint32_t id() const { return GetField<uint32_t>(VT_ID, 0); }
    float x() const { return GetField<float>(VT_X, 0.0f); }
    float y() const { return GetField<float>(VT_Y, 0.0f); }
    float z() const { return GetField<float>(VT_Z, 0.0f); }
    float velX() const { return GetField<float>(VT_VELX, 0.0f); }
    float velY() const { return GetField<float>(VT_VELY, 0.0f); }
    float velZ() const { return GetField<float>(VT_VELZ, 0.0f); }
    const flatbuffers::Vector<AM::fb::InputState>* inputStates() const
    {
        return GetPointer<const flatbuffers::Vector<AM::fb::InputState>*>(
            VT_INPUTSTATES);
    }
    bool Verify(flatbuffers::Verifier& verifier) const
    {
        return VerifyTableStart(verifier)
               && VerifyField<uint32_t>(verifier, VT_ID)
               && VerifyField<float>(verifier, VT_X)
               && VerifyField<float>(verifier, VT_Y)
               && VerifyField<float>(verifier, VT_Z)
               && VerifyField<float>(verifier, VT_VELX)
               && VerifyField<float>(verifier, VT_VELY)
               && VerifyField<float>(verifier, VT_VELZ)
               && VerifyOffset(verifier, VT_INPUTSTATES)
               && verifier.VerifyVector(inputStates()) && verifier.EndTable();
    }
};

struct EntityBuilder {
    typedef Entity Table;
    flatbuffers::FlatBufferBuilder& fbb_;
    flatbuffers::uoffset_t start_;
    void add_id(uint32_t id)
    {
        fbb_.AddElement<uint32_t>(Entity::VT_ID, id, 0);
    }
    void add_x(float x) { fbb_.AddElement<float>(Entity::VT_X, x, 0.0f); }
    void add_y(float y) { fbb_.AddElement<float>(Entity::VT_Y, y, 0.0f); }
    void add_z(float z) { fbb_.AddElement<float>(Entity::VT_Z, z, 0.0f); }
    void add_velX(float velX)
    {
        fbb_.AddElement<float>(Entity::VT_VELX, velX, 0.0f);
    }
    void add_velY(float velY)
    {
        fbb_.AddElement<float>(Entity::VT_VELY, velY, 0.0f);
    }
    void add_velZ(float velZ)
    {
        fbb_.AddElement<float>(Entity::VT_VELZ, velZ, 0.0f);
    }
    void add_inputStates(
        flatbuffers::Offset<flatbuffers::Vector<AM::fb::InputState>>
            inputStates)
    {
        fbb_.AddOffset(Entity::VT_INPUTSTATES, inputStates);
    }
    explicit EntityBuilder(flatbuffers::FlatBufferBuilder& _fbb)
    : fbb_(_fbb)
    {
        start_ = fbb_.StartTable();
    }
    flatbuffers::Offset<Entity> Finish()
    {
        const auto end = fbb_.EndTable(start_);
        auto o = flatbuffers::Offset<Entity>(end);
        return o;
    }
};

inline flatbuffers::Offset<Entity> CreateEntity(
    flatbuffers::FlatBufferBuilder& _fbb, uint32_t id = 0, float x = 0.0f,
    float y = 0.0f, float z = 0.0f, float velX = 0.0f, float velY = 0.0f,
    float velZ = 0.0f,
    flatbuffers::Offset<flatbuffers::Vector<AM::fb::InputState>> inputStates
    = 0)
{
    EntityBuilder builder_(_fbb);
    builder_.add_inputStates(inputStates);
    builder_.add_velZ(velZ);
    builder_.add_velY(velY);
    builder_.add_velX(velX);
    builder_.add_z(z);
    builder_.add_y(y);
    builder_.add_x(x);
    builder_.add_id(id);
    return builder_.Finish();
}

struct Entity::Traits {
    using type = Entity;
    static auto constexpr Create = CreateEntity;
};

inline flatbuffers::Offset<Entity>
    CreateEntityDirect(flatbuffers::FlatBufferBuilder& _fbb, uint32_t id = 0,
                       float x = 0.0f, float y = 0.0f, float z = 0.0f,
                       float velX = 0.0f, float velY = 0.0f, float velZ = 0.0f,
                       const std::vector<AM::fb::InputState>* inputStates
                       = nullptr)
{
    auto inputStates__
        = inputStates ? _fbb.CreateVector<AM::fb::InputState>(*inputStates) : 0;
    return AM::fb::CreateEntity(_fbb, id, x, y, z, velX, velY, velZ,
                                inputStates__);
}

struct EntityUpdate FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
    typedef EntityUpdateBuilder Builder;
    struct Traits;
    enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
        VT_ENTITIES = 4
    };
    const flatbuffers::Vector<flatbuffers::Offset<AM::fb::Entity>>*
        entities() const
    {
        return GetPointer<
            const flatbuffers::Vector<flatbuffers::Offset<AM::fb::Entity>>*>(
            VT_ENTITIES);
    }
    bool Verify(flatbuffers::Verifier& verifier) const
    {
        return VerifyTableStart(verifier) && VerifyOffset(verifier, VT_ENTITIES)
               && verifier.VerifyVector(entities())
               && verifier.VerifyVectorOfTables(entities())
               && verifier.EndTable();
    }
};

struct EntityUpdateBuilder {
    typedef EntityUpdate Table;
    flatbuffers::FlatBufferBuilder& fbb_;
    flatbuffers::uoffset_t start_;
    void add_entities(flatbuffers::Offset<
                      flatbuffers::Vector<flatbuffers::Offset<AM::fb::Entity>>>
                          entities)
    {
        fbb_.AddOffset(EntityUpdate::VT_ENTITIES, entities);
    }
    explicit EntityUpdateBuilder(flatbuffers::FlatBufferBuilder& _fbb)
    : fbb_(_fbb)
    {
        start_ = fbb_.StartTable();
    }
    flatbuffers::Offset<EntityUpdate> Finish()
    {
        const auto end = fbb_.EndTable(start_);
        auto o = flatbuffers::Offset<EntityUpdate>(end);
        return o;
    }
};

inline flatbuffers::Offset<EntityUpdate> CreateEntityUpdate(
    flatbuffers::FlatBufferBuilder& _fbb,
    flatbuffers::Offset<
        flatbuffers::Vector<flatbuffers::Offset<AM::fb::Entity>>>
        entities
    = 0)
{
    EntityUpdateBuilder builder_(_fbb);
    builder_.add_entities(entities);
    return builder_.Finish();
}

struct EntityUpdate::Traits {
    using type = EntityUpdate;
    static auto constexpr Create = CreateEntityUpdate;
};

inline flatbuffers::Offset<EntityUpdate> CreateEntityUpdateDirect(
    flatbuffers::FlatBufferBuilder& _fbb,
    const std::vector<flatbuffers::Offset<AM::fb::Entity>>* entities = nullptr)
{
    auto entities__
        = entities ? _fbb.CreateVector<flatbuffers::Offset<AM::fb::Entity>>(
              *entities)
                   : 0;
    return AM::fb::CreateEntityUpdate(_fbb, entities__);
}

inline const AM::fb::EntityUpdate* GetEntityUpdate(const void* buf)
{
    return flatbuffers::GetRoot<AM::fb::EntityUpdate>(buf);
}

inline const AM::fb::EntityUpdate* GetSizePrefixedEntityUpdate(const void* buf)
{
    return flatbuffers::GetSizePrefixedRoot<AM::fb::EntityUpdate>(buf);
}

inline bool VerifyEntityUpdateBuffer(flatbuffers::Verifier& verifier)
{
    return verifier.VerifyBuffer<AM::fb::EntityUpdate>(nullptr);
}

inline bool
    VerifySizePrefixedEntityUpdateBuffer(flatbuffers::Verifier& verifier)
{
    return verifier.VerifySizePrefixedBuffer<AM::fb::EntityUpdate>(nullptr);
}

inline void
    FinishEntityUpdateBuffer(flatbuffers::FlatBufferBuilder& fbb,
                             flatbuffers::Offset<AM::fb::EntityUpdate> root)
{
    fbb.Finish(root);
}

inline void FinishSizePrefixedEntityUpdateBuffer(
    flatbuffers::FlatBufferBuilder& fbb,
    flatbuffers::Offset<AM::fb::EntityUpdate> root)
{
    fbb.FinishSizePrefixed(root);
}

} // namespace fb
} // namespace AM

#endif // FLATBUFFERS_GENERATED_BASIC_AM_FB_H_
