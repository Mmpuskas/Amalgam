// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_MESSAGE_AM_H_
#define FLATBUFFERS_GENERATED_MESSAGE_AM_H_

#include "flatbuffers/flatbuffers.h"

namespace AM {

struct ConnectionRequest;
struct ConnectionRequestBuilder;

struct ConnectionResponse;
struct ConnectionResponseBuilder;

struct PositionComponent;

struct MovementComponent;

struct Rect;

struct SpriteComponent;

struct Entity;
struct EntityBuilder;

struct EntityUpdate;
struct EntityUpdateBuilder;

struct Message;
struct MessageBuilder;

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) PositionComponent FLATBUFFERS_FINAL_CLASS {
 private:
  float x_;
  float y_;

 public:
  PositionComponent() {
    memset(static_cast<void *>(this), 0, sizeof(PositionComponent));
  }
  PositionComponent(float _x, float _y)
      : x_(flatbuffers::EndianScalar(_x)),
        y_(flatbuffers::EndianScalar(_y)) {
  }
  float x() const {
    return flatbuffers::EndianScalar(x_);
  }
  float y() const {
    return flatbuffers::EndianScalar(y_);
  }
};
FLATBUFFERS_STRUCT_END(PositionComponent, 8);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) MovementComponent FLATBUFFERS_FINAL_CLASS {
 private:
  float velX_;
  float velY_;
  float maxVelX_;
  float maxVelY_;

 public:
  MovementComponent() {
    memset(static_cast<void *>(this), 0, sizeof(MovementComponent));
  }
  MovementComponent(float _velX, float _velY, float _maxVelX, float _maxVelY)
      : velX_(flatbuffers::EndianScalar(_velX)),
        velY_(flatbuffers::EndianScalar(_velY)),
        maxVelX_(flatbuffers::EndianScalar(_maxVelX)),
        maxVelY_(flatbuffers::EndianScalar(_maxVelY)) {
  }
  float velX() const {
    return flatbuffers::EndianScalar(velX_);
  }
  float velY() const {
    return flatbuffers::EndianScalar(velY_);
  }
  float maxVelX() const {
    return flatbuffers::EndianScalar(maxVelX_);
  }
  float maxVelY() const {
    return flatbuffers::EndianScalar(maxVelY_);
  }
};
FLATBUFFERS_STRUCT_END(MovementComponent, 16);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) Rect FLATBUFFERS_FINAL_CLASS {
 private:
  int32_t x_;
  int32_t y_;
  int32_t w_;
  int32_t h_;

 public:
  Rect() {
    memset(static_cast<void *>(this), 0, sizeof(Rect));
  }
  Rect(int32_t _x, int32_t _y, int32_t _w, int32_t _h)
      : x_(flatbuffers::EndianScalar(_x)),
        y_(flatbuffers::EndianScalar(_y)),
        w_(flatbuffers::EndianScalar(_w)),
        h_(flatbuffers::EndianScalar(_h)) {
  }
  int32_t x() const {
    return flatbuffers::EndianScalar(x_);
  }
  int32_t y() const {
    return flatbuffers::EndianScalar(y_);
  }
  int32_t w() const {
    return flatbuffers::EndianScalar(w_);
  }
  int32_t h() const {
    return flatbuffers::EndianScalar(h_);
  }
};
FLATBUFFERS_STRUCT_END(Rect, 16);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) SpriteComponent FLATBUFFERS_FINAL_CLASS {
 private:
  int16_t textureID_;
  int16_t padding0__;
  AM::Rect posInTexture_;
  AM::Rect posInWorld_;

 public:
  SpriteComponent() {
    memset(static_cast<void *>(this), 0, sizeof(SpriteComponent));
  }
  SpriteComponent(int16_t _textureID, const AM::Rect &_posInTexture, const AM::Rect &_posInWorld)
      : textureID_(flatbuffers::EndianScalar(_textureID)),
        padding0__(0),
        posInTexture_(_posInTexture),
        posInWorld_(_posInWorld) {
    (void)padding0__;
  }
  int16_t textureID() const {
    return flatbuffers::EndianScalar(textureID_);
  }
  const AM::Rect &posInTexture() const {
    return posInTexture_;
  }
  const AM::Rect &posInWorld() const {
    return posInWorld_;
  }
};
FLATBUFFERS_STRUCT_END(SpriteComponent, 36);

struct ConnectionRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ConnectionRequestBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PLAYERNAME = 4
  };
  const flatbuffers::String *playerName() const {
    return GetPointer<const flatbuffers::String *>(VT_PLAYERNAME);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_PLAYERNAME) &&
           verifier.VerifyString(playerName()) &&
           verifier.EndTable();
  }
};

struct ConnectionRequestBuilder {
  typedef ConnectionRequest Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_playerName(flatbuffers::Offset<flatbuffers::String> playerName) {
    fbb_.AddOffset(ConnectionRequest::VT_PLAYERNAME, playerName);
  }
  explicit ConnectionRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<ConnectionRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ConnectionRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<ConnectionRequest> CreateConnectionRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> playerName = 0) {
  ConnectionRequestBuilder builder_(_fbb);
  builder_.add_playerName(playerName);
  return builder_.Finish();
}

inline flatbuffers::Offset<ConnectionRequest> CreateConnectionRequestDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *playerName = nullptr) {
  auto playerName__ = playerName ? _fbb.CreateString(playerName) : 0;
  return AM::CreateConnectionRequest(
      _fbb,
      playerName__);
}

struct ConnectionResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ConnectionResponseBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_X = 4,
    VT_Y = 6
  };
  float x() const {
    return GetField<float>(VT_X, 0.0f);
  }
  float y() const {
    return GetField<float>(VT_Y, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_X) &&
           VerifyField<float>(verifier, VT_Y) &&
           verifier.EndTable();
  }
};

struct ConnectionResponseBuilder {
  typedef ConnectionResponse Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_x(float x) {
    fbb_.AddElement<float>(ConnectionResponse::VT_X, x, 0.0f);
  }
  void add_y(float y) {
    fbb_.AddElement<float>(ConnectionResponse::VT_Y, y, 0.0f);
  }
  explicit ConnectionResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<ConnectionResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ConnectionResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<ConnectionResponse> CreateConnectionResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    float x = 0.0f,
    float y = 0.0f) {
  ConnectionResponseBuilder builder_(_fbb);
  builder_.add_y(y);
  builder_.add_x(x);
  return builder_.Finish();
}

struct Entity FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef EntityBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_NAME = 6,
    VT_POSITIONCOMPONENT = 8,
    VT_MOVEMENTCOMPONENT = 10,
    VT_SPRITECOMPONENT = 12
  };
  uint32_t id() const {
    return GetField<uint32_t>(VT_ID, 0);
  }
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  const AM::PositionComponent *positionComponent() const {
    return GetStruct<const AM::PositionComponent *>(VT_POSITIONCOMPONENT);
  }
  const AM::MovementComponent *movementComponent() const {
    return GetStruct<const AM::MovementComponent *>(VT_MOVEMENTCOMPONENT);
  }
  const AM::SpriteComponent *spriteComponent() const {
    return GetStruct<const AM::SpriteComponent *>(VT_SPRITECOMPONENT);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_ID) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyField<AM::PositionComponent>(verifier, VT_POSITIONCOMPONENT) &&
           VerifyField<AM::MovementComponent>(verifier, VT_MOVEMENTCOMPONENT) &&
           VerifyField<AM::SpriteComponent>(verifier, VT_SPRITECOMPONENT) &&
           verifier.EndTable();
  }
};

struct EntityBuilder {
  typedef Entity Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id(uint32_t id) {
    fbb_.AddElement<uint32_t>(Entity::VT_ID, id, 0);
  }
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(Entity::VT_NAME, name);
  }
  void add_positionComponent(const AM::PositionComponent *positionComponent) {
    fbb_.AddStruct(Entity::VT_POSITIONCOMPONENT, positionComponent);
  }
  void add_movementComponent(const AM::MovementComponent *movementComponent) {
    fbb_.AddStruct(Entity::VT_MOVEMENTCOMPONENT, movementComponent);
  }
  void add_spriteComponent(const AM::SpriteComponent *spriteComponent) {
    fbb_.AddStruct(Entity::VT_SPRITECOMPONENT, spriteComponent);
  }
  explicit EntityBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Entity> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Entity>(end);
    return o;
  }
};

inline flatbuffers::Offset<Entity> CreateEntity(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t id = 0,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    const AM::PositionComponent *positionComponent = 0,
    const AM::MovementComponent *movementComponent = 0,
    const AM::SpriteComponent *spriteComponent = 0) {
  EntityBuilder builder_(_fbb);
  builder_.add_spriteComponent(spriteComponent);
  builder_.add_movementComponent(movementComponent);
  builder_.add_positionComponent(positionComponent);
  builder_.add_name(name);
  builder_.add_id(id);
  return builder_.Finish();
}

inline flatbuffers::Offset<Entity> CreateEntityDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t id = 0,
    const char *name = nullptr,
    const AM::PositionComponent *positionComponent = 0,
    const AM::MovementComponent *movementComponent = 0,
    const AM::SpriteComponent *spriteComponent = 0) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  return AM::CreateEntity(
      _fbb,
      id,
      name__,
      positionComponent,
      movementComponent,
      spriteComponent);
}

struct EntityUpdate FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef EntityUpdateBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ENTITIES = 4
  };
  const flatbuffers::Vector<flatbuffers::Offset<AM::Entity>> *entities() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<AM::Entity>> *>(VT_ENTITIES);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ENTITIES) &&
           verifier.VerifyVector(entities()) &&
           verifier.VerifyVectorOfTables(entities()) &&
           verifier.EndTable();
  }
};

struct EntityUpdateBuilder {
  typedef EntityUpdate Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_entities(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<AM::Entity>>> entities) {
    fbb_.AddOffset(EntityUpdate::VT_ENTITIES, entities);
  }
  explicit EntityUpdateBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<EntityUpdate> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<EntityUpdate>(end);
    return o;
  }
};

inline flatbuffers::Offset<EntityUpdate> CreateEntityUpdate(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<AM::Entity>>> entities = 0) {
  EntityUpdateBuilder builder_(_fbb);
  builder_.add_entities(entities);
  return builder_.Finish();
}

inline flatbuffers::Offset<EntityUpdate> CreateEntityUpdateDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<AM::Entity>> *entities = nullptr) {
  auto entities__ = entities ? _fbb.CreateVector<flatbuffers::Offset<AM::Entity>>(*entities) : 0;
  return AM::CreateEntityUpdate(
      _fbb,
      entities__);
}

struct Message FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef MessageBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CONNECTIONREQUEST = 4,
    VT_CONNECTIONRESPONSE = 6,
    VT_ENTITYUPDATE = 8
  };
  const AM::ConnectionRequest *connectionRequest() const {
    return GetPointer<const AM::ConnectionRequest *>(VT_CONNECTIONREQUEST);
  }
  const AM::ConnectionResponse *connectionResponse() const {
    return GetPointer<const AM::ConnectionResponse *>(VT_CONNECTIONRESPONSE);
  }
  const AM::EntityUpdate *entityUpdate() const {
    return GetPointer<const AM::EntityUpdate *>(VT_ENTITYUPDATE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_CONNECTIONREQUEST) &&
           verifier.VerifyTable(connectionRequest()) &&
           VerifyOffset(verifier, VT_CONNECTIONRESPONSE) &&
           verifier.VerifyTable(connectionResponse()) &&
           VerifyOffset(verifier, VT_ENTITYUPDATE) &&
           verifier.VerifyTable(entityUpdate()) &&
           verifier.EndTable();
  }
};

struct MessageBuilder {
  typedef Message Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_connectionRequest(flatbuffers::Offset<AM::ConnectionRequest> connectionRequest) {
    fbb_.AddOffset(Message::VT_CONNECTIONREQUEST, connectionRequest);
  }
  void add_connectionResponse(flatbuffers::Offset<AM::ConnectionResponse> connectionResponse) {
    fbb_.AddOffset(Message::VT_CONNECTIONRESPONSE, connectionResponse);
  }
  void add_entityUpdate(flatbuffers::Offset<AM::EntityUpdate> entityUpdate) {
    fbb_.AddOffset(Message::VT_ENTITYUPDATE, entityUpdate);
  }
  explicit MessageBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Message> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Message>(end);
    return o;
  }
};

inline flatbuffers::Offset<Message> CreateMessage(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<AM::ConnectionRequest> connectionRequest = 0,
    flatbuffers::Offset<AM::ConnectionResponse> connectionResponse = 0,
    flatbuffers::Offset<AM::EntityUpdate> entityUpdate = 0) {
  MessageBuilder builder_(_fbb);
  builder_.add_entityUpdate(entityUpdate);
  builder_.add_connectionResponse(connectionResponse);
  builder_.add_connectionRequest(connectionRequest);
  return builder_.Finish();
}

inline const AM::Message *GetMessage(const void *buf) {
  return flatbuffers::GetRoot<AM::Message>(buf);
}

inline const AM::Message *GetSizePrefixedMessage(const void *buf) {
  return flatbuffers::GetSizePrefixedRoot<AM::Message>(buf);
}

inline bool VerifyMessageBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<AM::Message>(nullptr);
}

inline bool VerifySizePrefixedMessageBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<AM::Message>(nullptr);
}

inline void FinishMessageBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<AM::Message> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedMessageBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<AM::Message> root) {
  fbb.FinishSizePrefixed(root);
}

}  // namespace AM

#endif  // FLATBUFFERS_GENERATED_MESSAGE_AM_H_
